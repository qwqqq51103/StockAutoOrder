# K線週期設計限制與解決方案

## 📅 日期
2025-10-23

---

## ⚠️ 發現的設計問題

### 問題描述

在實作K線週期切換功能後，發現了以下嚴重的使用者體驗問題：

### 問題1：歷史K線消失 ❌

**現象：**
- 程式啟動後使用30秒週期，累積了多根蠟燭
- 切換到1分鐘週期時，**所有30秒的K線都消失了**
- 只顯示1分鐘週期已累積的少量K線（可能只有1-2根）

**原因：**
```java
// 每個週期都有獨立的數據儲存
Map<Integer, OHLCSeries> minuteToSeries = new HashMap<>();

minuteToSeries.get(-30)  // 30秒K線的獨立數據
minuteToSeries.get(1)    // 1分鐘K線的獨立數據
```

系統在運行時**同時累積**所有週期的K線數據，但每個週期的數據是**完全獨立**的：
- 30秒週期：只在30秒整數倍時間點更新
- 1分鐘週期：只在1分鐘整數倍時間點更新

切換週期時，只是切換顯示的數據集，**不會重新計算**。

---

### 問題2：時間對齊混亂 ❌

**現象：**
- 使用5秒週期
- 在第4秒時發生信號（多空信號、大單、失衡）
- 標記顯示在K線的**中間位置**，造成視覺混亂

**時間軸示例：**
```
時間:     00:00    00:05    00:10    00:15
K線:     |████|    |████|    |████|    |████|
信號:        ●  ←  這個標記在00:04秒發生
             ↑
          不對齊！
```

雖然程式碼中使用了 `period.getFirstMillisecond()` 來對齊標記，但這只是**將標記對齊到當前K線的起始時間**，並不能解決標記在K線中間的問題。

---

### 問題3：切換週期時的時間跳躍 ❌

**現象：**
- 當前時間：10:30:45（45秒）
- 從30秒週期切換到1分鐘週期
- K線圖會跳到下一個1分鐘整數倍（10:31:00）才開始新的K線

**原因：**
K線數據的時間桶是預先對齊的：
```java
// 30秒週期時間桶
10:30:00, 10:30:30, 10:31:00, 10:31:30...

// 1分鐘週期時間桶
10:30:00, 10:31:00, 10:32:00...
```

在10:30:45切換到1分鐘週期時，當前正在形成的K線是10:30:00這根，但30秒週期已經有10:30:00和10:30:30兩根K線了。

---

## 🎯 為什麼之前沒有UI控件？

現在明白了！**這不是遺漏，而是刻意隱藏**。

開發者早就發現了這些問題：
1. ✅ 週期數據結構設計完成（`minuteToSeries`, `minuteToCollection`）
2. ✅ 週期切換邏輯實作完成（`switchKlineInterval()` 方法）
3. ✅ 週期選項定義完成（`klineMinutes`, `klineSeconds`）
4. ❌ **刻意不創建UI控件**，避免用戶誤用

---

## 💡 根本原因分析

### 架構設計限制

當前的K線系統採用**多週期並行累積**的架構：

```
價格更新（每個tick）
    ↓
同時更新所有週期
    ├─ 10秒週期 → 檢查是否到10秒整數倍 → 更新10秒K線
    ├─ 30秒週期 → 檢查是否到30秒整數倍 → 更新30秒K線
    ├─ 1分鐘週期 → 檢查是否到1分鐘整數倍 → 更新1分鐘K線
    └─ 5分鐘週期 → 檢查是否到5分鐘整數倍 → 更新5分鐘K線
```

這種架構的優點：
- ✅ 效能好：每個週期獨立更新，不需要重新計算
- ✅ 記憶體可控：每個週期只保留有限根數

這種架構的缺點：
- ❌ 無法在切換週期時保留完整歷史
- ❌ 標記時間與K線時間桶對齊困難
- ❌ 切換週期時用戶體驗差

---

## 🔧 可能的解決方案

### 方案1：移除週期切換功能（已採用）⭐

**優點：**
- ✅ 簡單直接
- ✅ 避免用戶困惑
- ✅ 保持系統穩定

**缺點：**
- ❌ 失去週期切換的靈活性
- ❌ 需要重啟程式才能改變週期

**實作狀態：** ✅ 已完成
- 移除了工具列的週期選擇下拉選單
- 保留底層多週期數據結構（以備未來使用）
- 保留 `switchKlineInterval()` 方法（可透過其他方式觸發）

---

### 方案2：改用單週期+歷史重算架構（複雜）

**概念：**
只保留一份**最細粒度**的歷史價格數據（如tick級別），切換週期時重新計算K線。

**架構：**
```
價格更新
    ↓
儲存到歷史tick數據（ArrayList<PriceTick>）
    ↓
根據當前週期設定，從歷史數據重算K線
```

**優點：**
- ✅ 切換週期時可以保留完整歷史
- ✅ 所有週期的K線數據一致
- ✅ 標記可以正確對齊到任何週期

**缺點：**
- ❌ 需要大量重構現有代碼
- ❌ 記憶體使用增加（需要保留所有tick數據）
- ❌ 效能開銷大（每次切換都要重算）
- ❌ 複雜度高，容易產生新bug

**實作難度：** 🔴 極高（估計需要重寫60%以上的K線邏輯）

---

### 方案3：限制式週期切換（折衷）

**概念：**
- 只允許切換到**倍數關係**的週期
- 例如：10秒 → 30秒 → 1分鐘（可以切換）
- 但不允許：30秒 → 1分鐘（不是整數倍）

**規則：**
```
可切換路徑：
10秒 → 30秒 → 1分鐘 → 5分鐘 → 10分鐘 → 30分鐘 → 60分鐘

不可切換：
30秒 ↔ 1分鐘（60秒 ≠ 30秒的整數倍）
```

**優點：**
- ✅ 可以提供部分週期切換功能
- ✅ 歷史K線可以通過聚合小週期數據生成
- ✅ 實作相對簡單

**缺點：**
- ❌ 切換路徑受限
- ❌ 標記對齊問題仍然存在
- ❌ 用戶體驗仍然不佳

**實作難度：** 🟡 中等

---

### 方案4：僅允許程式啟動時設定週期（實用）⭐

**概念：**
- 移除執行時切換功能
- 在程式啟動時提供週期選擇對話框
- 或透過設定檔指定預設週期

**實作範例：**
```java
// 程式啟動時顯示對話框
String[] options = {"10秒", "30秒", "1分", "5分", "15分", "30分", "60分"};
String choice = (String) JOptionPane.showInputDialog(
    null,
    "請選擇K線週期：",
    "K線週期設定",
    JOptionPane.PLAIN_MESSAGE,
    null,
    options,
    options[0]
);

// 根據選擇設定 currentKlineMinutes
```

**優點：**
- ✅ 實作簡單
- ✅ 用戶可以選擇週期
- ✅ 避免執行時切換的所有問題
- ✅ 不影響現有架構

**缺點：**
- ❌ 需要重啟程式才能改變週期
- ❌ 無法在執行時靈活調整

**實作難度：** 🟢 低（約30分鐘）

---

## 📋 當前狀態

### 已採用方案

**方案1：移除週期切換功能**

### 修改記錄

| 時間 | 動作 | 原因 |
|-----|------|------|
| 2025-10-23 早期 | 添加週期切換UI控件 | 誤以為功能未完成 |
| 2025-10-23 稍後 | 發現設計限制 | 用戶反饋問題 |
| 2025-10-23 當前 | 移除週期切換UI控件 | 避免用戶困惑 |

### 程式碼狀態

```java
// ✅ 保留：多週期數據結構
private final int[] klineMinutes = new int[]{1, 5, 10, 30, 60};
private final int[] klineSeconds = new int[]{10, 30, 60};
private final Map<Integer, OHLCSeries> minuteToSeries = new HashMap<>();

// ✅ 保留：預設週期設定
private int currentKlineMinutes = -10;  // 預設10秒K線

// ❌ 移除：UI控件
// klineIntervalCombo（不再創建）

// ✅ 保留：切換邏輯（可供未來改進使用）
private void switchKlineInterval() { ... }
```

---

## 💭 設計啟示

### 技術債務的識別

這個案例是典型的**技術債務**：
- 底層架構設計完善
- 但缺少上層整合
- 刻意隱藏UI以避免問題暴露

### 正確的開發順序

1. ✅ 設計核心架構（多週期數據結構）
2. ✅ 實作基礎功能（K線累積、顯示）
3. ✅ 測試基本場景
4. ❌ **跳過**：實作週期切換並測試各種邊緣情況
5. ❌ **跳過**：創建UI控件
6. ✅ 發現問題後，選擇暫時不提供UI

這種做法在**敏捷開發**中是合理的：
- 先確保核心功能穩定
- 有問題的功能暫時不暴露
- 等有更好的解決方案再開放

---

## 🎯 建議

### 如果您需要切換週期

**建議1：修改程式碼並重新編譯**
```java
// 檔案：MainView.java，第 214 行
private int currentKlineMinutes = -10;  // 改成您需要的週期

// 週期對照：
// -10  → 10秒
// -30  → 30秒
// -60  → 60秒
// 1    → 1分鐘
// 5    → 5分鐘
// 15   → 15分鐘
// 30   → 30分鐘
// 60   → 60分鐘
```

**建議2：多開程式實例**
- 開啟多個程式視窗，每個使用不同週期
- 例如：視窗1用10秒，視窗2用1分鐘，視窗3用5分鐘
- 同時觀察多個週期的走勢

---

## 📚 相關文件

- ~~`K線週期切換功能修復.md`~~ （已過時，不再適用）
- `如何修改K線週期.md` - K線週期程式碼修改指南（仍然有效）
- `K線週期快速參考.txt` - 快速查詢手冊（仍然有效）

---

## 🎓 總結

### 學到的教訓

1. **不是所有功能都應該暴露給用戶**
   - 底層實作完成 ≠ 功能可用
   - 需要考慮使用者體驗

2. **架構設計的權衡**
   - 多週期並行 vs 單週期重算
   - 效能 vs 靈活性
   - 簡單 vs 功能豐富

3. **技術債務的管理**
   - 有問題的功能暫時不開放
   - 保留底層結構以備未來改進
   - 明確記錄限制和原因

### 最終決定

✅ **移除週期切換UI控件**
- 避免用戶困惑
- 保持系統穩定
- 如需切換週期，請修改程式碼並重新編譯

這是**務實的選擇**，符合「可用性優先」的原則。

---

**文件版本：** 1.0  
**最後更新：** 2025-10-23  
**決策狀態：** ✅ 已確認並實施

